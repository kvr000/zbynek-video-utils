#!/usr/bin/env python3

# Utility to:
# - Collect subtitles and add them to the original video.
# - Convert subtitles between sub and srt formats
# - Set default streams in video
#
# zbynek-video-tool - various video files manipulation utilities
#
# Copyright 2024-2024 Zbynek Vyskovsky mailto:kvr000@gmail.com http://github.com/kvr000/ https://github.com/kvr000/zbynek-video-utils/ https://www.linkedin.com/in/zbynek-vyskovsky/
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


from __future__ import annotations

import tempfile
from functools import reduce
from math import floor, ceil
from typing import IO, override

from pydantic import BaseModel
import logging
import re
import os
import errno
import sys
import glob
from pathlib import Path
import subprocess
import argparse
import json


def format_shell(cmd: list[str]) -> str:
    return " ".join(map(lambda x: '"' + re.sub(r'[$"]', r'\\\0', x) + '"', cmd))


def silent_unlink(filename: str):
    try:
        os.remove(filename)
    except OSError as e:
        if e.errno != errno.ENOENT:
            raise


def comma_separated_string(str: str) -> list[str]:
    return str.split(",")


def readTextSegments(fd: IO, footer):
    pending = ""
    while (line := fd.readline()):
        if line.endswith("\r\n"):
            line = line[0:len(line)-2] + line[-1:]
        pending += line
        if line == footer:
            ret = pending
            pending = ""
            yield ret
    return


TIME_FORMAT_PATTERN = re.compile('^([-+])?(?:(\\d+):)?(?:(\\d+):)?(\\d+(?:\\.\\d*)?)$')


class TimeFormat:
    @staticmethod
    def str_to_us_time(time: str):
        if (match := TIME_FORMAT_PATTERN.match(time)) is None:
            raise ValueError("Expected [-][[hh:]mm:]ss[.ssssss] for time format, got: " + time)
        return (-1 if match.group(1) == "-" else 1) * (int(match.group(2) or 0)*3600000000 + int(match.group(3) or 0)*60000000 + int(float(match.group(4))*1000000))

    def us_time_to_str(time: int):
        remaining = time
        us = time % 1000000
        remaining = int(remaining / 1000000)
        seconds = remaining % 60
        remaining = (remaining / 60)
        minutes = remaining % 60
        remaining = (remaining / 60)
        hours = remaining
        return "%02d:%02d:%02d.%06d" % (hours, minutes, seconds, us)


class Ffmpeg:
    def ffprobePipe(self, args: list[str]) -> subprocess.Popen:
        full = [ "ffprobe" ]
        full.extend(args)
        print("Running: " + format_shell(full))
        return subprocess.Popen(full, stdout=subprocess.PIPE, text=True)

    def ffmpegPipe(self, args: list[str]) -> subprocess.Popen:
        full = [ "ffmpeg" ]
        full.extend(args)
        print("Running: " + format_shell(full))
        return subprocess.Popen(full, stdout=subprocess.PIPE, text=True)

    def ffprobeCapture(self, args: list[str]) -> str:
        proc = self.ffprobePipe(args)
        output = proc.communicate()[0]
        if proc.returncode != 0:
            raise OSError(f"Failed to run ffprobe: exit={proc.returncode}")
        return output

    def ffmpegCapture(self, args: list[str]) -> str:
        proc = self.ffmpegPipe(args)
        output = proc.communicate()[0]
        if proc.returncode != 0:
            raise OSError(f"Failed to run ffmpeg: args={format_shell(args)} exit={proc.returncode}")
        return output


class VideoFrame(BaseModel):
    id: int
    time_us: int


class VideoData:
    ffmpeg: Ffmpeg = Ffmpeg()

    filename: str

    cached_format_data: dict[str, object] = None

    cached_frames_list: list[VideoFrame] = None
    cached_frames_by_id: dict[int, VideoFrame] = None
    cached_frames_by_time_us: dict[int, VideoFrame] = None

    def __init__(self, filename):
        self.filename = filename

    def duration(self):
        return int(round(float(self.format_data()["format"]["duration"]) * 1000000))

    def frames_by_time_us(self):
        if self.cached_frames_by_time_us is None:
            self.build_frames_index()
        return self.cached_frames_by_time_us

    def frames_by_id(self):
        if self.cached_frames_by_id is None:
            self.build_frames_index()
        return self.cached_frames_by_id

    def frame_by_id(self, frame_id):
        return self.frames_by_id().get(frame_id)

    def lowest_frame_by_time_us(self, time_us):
        if self.cached_frames_list is None:
            self.build_frames_index()
        i = 0
        j = len(self.cached_frames_list)-1
        if j < 0 or time_us > self.cached_frames_list[j].time_us:
            return None
        while i < j:
            mid = (i+j) // 2
            if time_us > self.cached_frames_list[mid].time_us:
                i = mid+1
            elif time_us < self.cached_frames_list[mid].time_us:
                j = mid
            else:
                return self.cached_frames_list[mid]
        return self.cached_frames_list[i]

    def frame_by_range_type(self, range_type, value):
        if range_type == "time":
            return self.lowest_frame_by_time_us(value)
        elif range_type == "frame":
            return self.frame_by_id(value)
        else:
            raise NotImplementedError("Unsupported range_type (supported time,frame): " + range_type)

    def time_by_range_type(self, range_type, value):
        if range_type == "time":
            return value
        elif range_type == "frame":
            return self.frame_by_id(value).time_us
        else:
            raise NotImplementedError("Unsupported range_type (supported time,frame): " + range_type)

    def build_frames_index(self):
        logging.info("Obtaining video frames index, it may take few minutes")
        if self.filename is None:
            raise IOError("Video filename must be specified")
        proc = subprocess.Popen(["ffprobe", "-hide_banner", "-loglevel", "fatal", "-show_error", "-threads", "auto", "-select_streams", "v:0", "-show_frames", self.filename], stdout=subprocess.PIPE, text=True)
        id = 0
        self.cached_frames_list = list()
        self.cached_frames_by_id = dict()
        self.cached_frames_by_time_us = dict()
        for text in VideoData.readFrames(proc.stdout):
            frame = VideoFrame(id=id, time_us=int(round(float(text['best_effort_timestamp_time']) * 1000000)))
            self.cached_frames_list.append(frame)
            self.cached_frames_by_id[frame.id] = frame
            self.cached_frames_by_time_us[frame.time_us] = frame
            id = id+1
            if id % 10000 == 0:
                logging.info("Obtaining video frames index, progress=%d hours=%.6f", id, frame.time_us / 3600000000)

    def format_data(self) -> dict[str, object]:
        if self.cached_format_data is None:
            if self.filename is None:
                raise IOError("Video filename must be specified")
            text = self.ffmpeg.ffprobeCapture(["-v", "quiet", "-print_format", "json", "-show_format", "-show_streams", "--", self.filename])
            self.cached_format_data = json.loads(text)
        return self.cached_format_data

    @staticmethod
    def readFrames(fd: IO):
        for frame in readTextSegments(fd, "[/FRAME]\n"):
            data = {}
            for line in frame.split("\n"):
                split = line.split("=", 2)
                if len(split) == 2:
                    data[split[0]] = split[1]
            yield data
        return


class VideoManipulations:
    ffmpeg: Ffmpeg = Ffmpeg()

    def cutVideo(self, output: str, input: str, start_us: int, end_us: int | None):
        args = ["-hide_banner", "-loglevel", "error", "-ss", TimeFormat.us_time_to_str(start_us)]
        if end_us is not None:
            args.extend(["-to", TimeFormat.us_time_to_str(end_us)])
        args.extend(["-i", input, "-c", "copy", output])
        self.ffmpeg.ffmpegCapture(args)

    def concatVideos(self, output: str, inputs: list[str]):
        listfile = tempfile.NamedTemporaryFile("w", delete_on_close=False)
        try:
            for input in inputs:
                print("file " + os.path.abspath(input), file=listfile)
            listfile.close()

            args = ["-hide_banner", "-loglevel", "error", "-f", "concat", "-safe", "0", "-i", listfile.name, "-c", "copy", output]

            #print(f"Executing ffmpeg: {format_shell(args)}", file=sys.stderr)
            self.ffmpeg.ffmpegCapture(args)
        finally:
            listfile.close()
            os.unlink(listfile.name)


class SubtitleEntry(BaseModel):
    range_type: str # frame, time
    start: int
    end: int
    text: list[str]


SUB_LINE_PATTERN = re.compile('^\\{(\\d+)\\}\\{(\\d+)\\}(.*)')
DIGITS_PATTERN = re.compile('^\\d+$')
SRT_TIME_RANGE_PATTERN = re.compile('^(\\d+):(\\d+):(\\d+)[,.](\\d+) --> (\\d+):(\\d+):(\\d+)[,.](\\d+)$')


class Subtitles:
    filename: str
    type: str
    entries: list[SubtitleEntry]

    def __init__(self, filename: str, type: str, entries: list[SubtitleEntry]):
        self.filename = filename
        self.type = type
        self.entries = entries

    @classmethod
    def read_subtitles(cls, filename: str) -> Subtitles:
        if filename.endswith(".sub"):
            return cls.read_subtitles_sub(filename)
        elif filename.endswith(".srt"):
            return cls.read_subtitles_srt(filename)
        else:
            raise NotImplementedError("Subtitles format not supported for reading: " + filename)

    @classmethod
    def read_subtitles_sub(cls, filename: str) -> Subtitles:
        if not filename.endswith(".sub"):
            raise AttributeError("Filename must end with .sub suffix, got: " + filename)
        with open(filename, "rt", encoding='utf-8-sig') as fd:
            entries = []
            while (line := fd.readline()):
                line = line.rstrip()
                if (match := SUB_LINE_PATTERN.match(line)) is None:
                    logging.warn("Failed to match line in subtitles: " + line)
                else:
                    entries.append(SubtitleEntry(range_type="frame", start=match.group(1), end=match.group(2), text=match.group(3).split("|")))
            return Subtitles(filename, "sub", entries)

    @classmethod
    def read_subtitles_srt(cls, filename: str) -> Subtitles:
        if not filename.endswith(".srt"):
            raise AttributeError("Filename must end with .srt suffix, got: " + filename)
        with open(filename, "rt", encoding='utf-8-sig') as fd:
            entries = []
            for frame in readTextSegments(fd, "\n"):
                lines = frame.split("\n")
                if all(t == "" for t in lines):
                    continue
                if DIGITS_PATTERN.match(lines[0]) is None:
                    raise ValueError("Expected number on the first line of srt frame, got: " + lines[0])
                if (srt_time := SRT_TIME_RANGE_PATTERN.match(lines[1])) is None:
                    raise ValueError("Expected time range on the second line of srt frame, got: " + lines[1])
                while lines[-1] == "":
                    lines.pop()
                entries.append(SubtitleEntry(
                    range_type="time",
                    start=int(srt_time.group(1))*3600000000+int(srt_time.group(2))*60000000+int(srt_time.group(3))*1000000+int(srt_time.group(4))*1000,
                    end=int(srt_time.group(5))*3600000000+int(srt_time.group(6))*60000000+int(srt_time.group(7))*1000000+int(srt_time.group(8))*1000,
                    text=lines[2:]
                ))
            return Subtitles(filename, "srt", entries)

    @staticmethod
    def us_to_srt_time(us: int) -> str:
        second = int(us/1000000)
        minute = int(second/60)
        hour = int(minute/60)
        milli = int((us - second*1000000)/1000)
        second = second - minute*60
        minute = minute - hour*60

        return "%02d:%02d:%02d,%03d" % ( hour, minute, second, milli)


class Command:
    def run(self, args) -> int:
        exit: int | None = self.setup(args)
        if exit is not None:
            return exit
        return self.execute()

    def setup(self, args) -> int | None:
        return None

    def execute(self) -> int:
        return 0


class MainSubCommand(Command):
    main: Main

    def __init__(self, parent):
        self.main = parent


class FfmpegMainSubCommand(MainSubCommand):
    def runFfmpegOutput(self, args: list[str]) -> int:
        safe = True
        args.extend(["--", self.main.video_output])
        try:
            print(f"Executing ffmpeg: {format_shell(args)}", file=sys.stderr)
            ret: int = subprocess.run(args).returncode
            if ret != 0:
                print(f"process exited with error: exit={ret} : {format_shell(args)}", file=sys.stderr)
            #safe = False
            #shutil.copyfile(tmp, self.main.video_input)
            #safe = True
            return ret
        finally:
            if safe:
                #silent_unlink(tmp)
                pass


class SubtitleConvertCommand(MainSubCommand):
    inputs: list[str] = list()
    output: list[str] = list()
    type: str | None
    delay: list[str] = list()

    delay_start_at: int | None = None
    delay_start_delay: int | None = None
    delay_end_at: int | None = None
    delay_end_delay: int | None = None

    video_data: VideoData

    def setup(self, args) -> int | None:
        parser = argparse.ArgumentParser(prog=args[0], description="Convert subtitles")
        parser.add_argument("-i", "--input", type=str, dest="inputs", action="append", nargs='?')
        parser.add_argument("-o", "--output", type=str, dest="output", action="append", nargs="?")
        parser.add_argument("-t", "--type", type=str, dest="type")
        parser.add_argument("--delay", type=str, dest="delay", action="append", nargs="?")
        parser.add_argument("inputs", type=str, action='extend', nargs='+')

        parser.parse_args(args[1:], namespace=self)

        if not self.inputs:
            print("-i input argument is mandatory", file=sys.stderr)
            return 122
        if self.output is None and self.type is None:
            print("one of -o output or -t type arguments is mandatory", file=sys.stderr)
            return 122

        if len(self.output) == 0:
            if self.type is None:
                print("-t type must be specified if there are multiple inputs", file=sys.stderr)
                return 122
            self.output = list(map(lambda input: Path(input).stem + "." + self.type, self.inputs))
        elif len(self.inputs) > 1:
            print("-o output must not be specified if there are multiple inputs", file=sys.stderr)
            return 122
        else:
            if self.type is None:
                extension = Path(self.output[0]).suffix
                if extension == ".sub":
                    self.type = "sub"
                elif extension == ".srt":
                    self.type = "srt"
                else:
                    print("Unrecognized extension for subtitles: " + extension, file=sys.stderr)
                    return 122

        if len(self.delay) > 0:
            if len(self.delay) > 2:
                print("--delay must be specified at most twice", file=sys.stderr)
                return 122
            delay = SubtitleConvertCommand.parseDelay(self.delay[0])
            self.delay_start_at = delay[0]
            self.delay_start_delay = delay[1]
            if len(self.delay) > 1:
                delay = SubtitleConvertCommand.parseDelay(self.delay[1])
                self.delay_end_at = delay[0]
                self.delay_end_delay = delay[1]
            else:
                self.delay_end_at = self.delay_start_at + 1000000
                self.delay_end_delay = self.delay_start_delay

        return None

    def execute(self) -> int:
        self.video_data = VideoData(self.main.video_input)
        for input, output in dict(zip(self.inputs, self.output)).items():
            subtitles = Subtitles.read_subtitles(input)
            if self.type == "sub":
                self.writeToSub(subtitles, input, output)
            elif self.type == "srt":
                self.writeToSrt(subtitles, input, output)
            else:
                raise RuntimeError("Unhandled type: " + self.type)
        return 0

    @classmethod
    def parseDelay(cls, delay_str: str) -> list[int]:
        split = delay_str.split("=")
        if len(split) != 2:
            raise ValueError("Expected delay in form time=[-]delay, got: " + delay_str)
        return [ TimeFormat.str_to_us_time(split[0]), TimeFormat.str_to_us_time(split[1]) ]

    def writeToSrt(self, subtitles, input, output) -> None:
        with open(output, "wt") as fd:
            counter = 0
            for entry in subtitles.entries:
                counter = counter + 1
                start_time = self.adjustTime(self.video_data.time_by_range_type(entry.range_type, entry.start))
                end_time = self.adjustTime(self.video_data.time_by_range_type(entry.range_type, entry.end))
                #print(f"Converted time: orig={self.video_data.time_by_range_type(entry.range_type, entry.start)/1000000} new={start_time/1000000}")
                print("%d\n%s --> %s\n%s" % (
                    counter,
                    Subtitles.us_to_srt_time(start_time), Subtitles.us_to_srt_time(end_time),
                    "".join(map(lambda x: x+"\n", entry.text)),
                ), file=fd)

    def writeToSub(self, subtitles, input, output) -> None:
        with open(output, "wt") as fd:
            counter = 0
            for entry in subtitles.entries:
                counter = counter + 1
                start = self.video_data.lowest_frame_by_time_us(self.adjustTime(self.video_data.time_by_range_type(entry.range_type, entry.start)))
                end = self.video_data.lowest_frame_by_time_us(self.adjustTime(self.video_data.time_by_range_type(entry.range_type, entry.end)))
                print("{%d}{%d}%s" % (
                    start.id if start is not None else 999999999,
                    end.id if end is not None else 999999999,
                    "|".join(entry.text),
                ), file=fd)

    def adjustTime(self, time: int) -> int:
        if self.delay_start_at is None:
            return time
        return int((time - self.delay_start_at) / (self.delay_end_at - self.delay_start_at) * (self.delay_end_at + self.delay_end_delay - self.delay_start_at - self.delay_start_delay) + (self.delay_start_at + self.delay_start_delay))


class SubtitleEmbedCommand(MainSubCommand):
    priorities: list[str] | None = list()

    def __init__(self, parent):
        super().__init__(parent)

    def setup(self, args) -> int | None:
        parser = argparse.ArgumentParser(prog=args[0], description="Embed subtitles")
        parser.add_argument("--prio", type=comma_separated_string, dest="priorities", metavar="language priorities, comma separated or multiple arguments", action='extend')

        parser.parse_args(args[1:], namespace=self)

        if self.main.video_input is None or self.main.video_output is None or self.main.video_input == self.main.video_output:
            print("--vi video_input and --vo video_output must be both specified and must differ", file=sys.stderr)
            return 122

        return None

    def execute(self) -> int:
        prefix = Path(self.main.video_input).stem + "."
        pattern = glob.escape(prefix) + "*.srt"
        mapping = { x: None for x in self.priorities }
        for file in sorted(glob.glob(pattern)):
            mapping[Path(file).stem.removeprefix(prefix)] = file

        if len(mapping) == 0:
            print(f"None subtitles found matching the pattern: pattern={pattern}", file=sys.stderr)
            return 122

        video = self.main.readVideoData()

        args = ["ffmpeg", "-hide_banner", "-loglevel", "info", "-i", self.main.video_input, ]

        maps = []
        meta = []
        input_counter = 1
        subtitle_counter = 0

        for stream in video["streams"]:
            if stream['codec_type'] == 'subtitle':
                language = stream['tags']['language']
                if mapping.get(stream['tags']['language']) is not None:
                    print(f"Replacing: language={language} file={mapping.get(stream['tags']['language'])}", file=sys.stderr)
                    args.extend(["-i", mapping.get(stream['tags']['language'])])
                    maps.extend(["-map", str(input_counter) + ":s"])
                    meta.extend([f"-metadata:s:s:{subtitle_counter}", f"language={language}"])
                    del mapping[language]
                    input_counter = input_counter + 1
                else:
                    maps.extend(["-map", "0:" + str(stream['index'])])
                subtitle_counter = subtitle_counter + 1
            else:
                maps.extend(["-map", "0:" + str(stream['index'])])
        for language, file in mapping.items():
            if file is None:
                print(f"Warning: subtitle file not found: language={language}", file=sys.stderr)
            else:
                print(f"Adding: language={language} file={file}", file=sys.stderr)
                args.extend(["-i", file])
                maps.extend(["-map", str(input_counter) + ":s"])
                meta.extend([f"-metadata:s:s:{subtitle_counter}", f"language={language}"])
                input_counter = input_counter + 1
                subtitle_counter = subtitle_counter + 1
        args.extend(maps)
        args.extend(["-c", "copy"])
        if Path(self.main.video_output).suffix == ".mp4":
            args.extend(["-c:s", "mov_text"])
        args.extend(["-map_metadata", "0", "-movflags", "use_metadata_tags"])
        args.extend(meta)
        args.append('--')
        args.append(self.main.video_output)

        safe = True
        try:
            print(f"Executing ffmpeg: {format_shell(args)}", file=sys.stderr)
            exit: int = subprocess.run(args).returncode
            if exit != 0:
                print(f"process exited with error: exit={exit} : {format_shell(args)}", file=sys.stderr)
            #safe = False
            #shutil.copyfile(tmp, self.main.video_input)
            #safe = True
        finally:
            if safe:
                #silent_unlink(tmp)
                pass

        return exit


class LanguageReorderCommand(MainSubCommand):
    priorities: list[str] | None = list()

    def __init__(self, parent):
        super().__init__(parent)

    def setup(self, args) -> int | None:
        parser = argparse.ArgumentParser(prog=args[0], description="Language Reorder")
        parser.add_argument("--prio", type=comma_separated_string, dest="priorities", metavar="language priorities, comma separated or multiple arguments, 'none' in the list means ignore any unspecified", action='extend')

        parser.parse_args(args[1:], namespace=self)

        if self.main.video_input is None or self.main.video_output is None or self.main.video_input == self.main.video_output:
            print("--vi video_input and --vo video_output must be both specified and must differ", file=sys.stderr)
            return 122

        return None

    def execute(self) -> int:
        video = self.main.readVideoData()

        args = ["ffmpeg", "-hide_banner", "-loglevel", "info", "-i", self.main.video_input, ]

        maps = []
        meta = []

        subtitles = []
        audios = []

        base = 0

        for stream in video["streams"]:
            if stream['codec_type'] == 'audio':
                audios.append(stream)
            elif stream['codec_type'] == 'subtitle':
                subtitles.append(stream)
            else:
                maps.extend(["-map", "0:" + str(stream['index'])])
                if stream['codec_type'] == 'video':
                    base = len(maps)

        prios = {}
        for (i, lang) in enumerate(self.priorities):
            prios[lang] = i

        if 'none' in prios:
            subtitles = list(filter(lambda e: e['tags'].get('language', 'und') in prios, subtitles))
            audios = list(filter(lambda e: e['tags'].get('language', 'und') in prios, audios))
        audios.sort(key=lambda e: prios.get(e['tags'].get("language", "und"), sys.maxsize))
        subtitles.sort(key=lambda e: prios.get(e['tags'].get('language', 'und'), sys.maxsize))

        more_maps = []
        for i, audio in enumerate(audios):
            more_maps.extend(["-map", "0:" + str(audio['index'])])
            for tag in ['title']:
                if tag in audio['tags']:
                    meta.extend([f"-metadata:s:a:{i}", f"{tag}={audio['tags'][tag]}"])
        if audios:
            more_maps.extend(["-disposition:a:0", "default"])
        for i, subtitle in enumerate(subtitles):
            more_maps.extend(["-map", "0:" + str(subtitle['index'])])
            for tag in ['title']:
                if tag in subtitle['tags']:
                    meta.extend([f"-metadata:s:s:{i}", f"{tag}={subtitle['tags'][tag]}"])
        if subtitles:
            more_maps.extend(["-disposition:s:0", "default"])
        maps[base:base] = more_maps
        args.extend(maps)
        args.extend(["-c", "copy"])
        if Path(self.main.video_output).suffix == ".mp4":
            args.extend(["-c:s", "mov_text"])
        args.extend(["-map_metadata", "0", "-movflags", "use_metadata_tags"])
        args.extend(meta)
        args.append('--')
        args.append(self.main.video_output)

        safe = True
        try:
            print(f"Executing ffmpeg: {format_shell(args)}", file=sys.stderr)
            ret: int = subprocess.run(args).returncode
            if ret != 0:
                print(f"process exited with error: exit={ret} : {format_shell(args)}", file=sys.stderr)
            #safe = False
            #shutil.copyfile(tmp, self.main.video_input)
            #safe = True
        finally:
            if safe:
                #silent_unlink(tmp)
                pass

        return ret


class RetagUndCommand(FfmpegMainSubCommand):
    tag: str

    def __init__(self, parent):
        super().__init__(parent)

    def setup(self, args) -> int | None:
        parser = argparse.ArgumentParser(prog=args[0], description="Retag unknown")
        parser.add_argument("--tag", type=str, required=True, dest="tag", metavar="tag for und language")

        parser.parse_args(args[1:], namespace=self)

        if self.main.video_input is None or self.main.video_output is None or self.main.video_input == self.main.video_output:
            print("--vi video_input and --vo video_output must be both specified and must differ", file=sys.stderr)
            return 122

        return None

    def execute(self) -> int:
        video = self.main.readVideoData()

        args = ["ffmpeg", "-hide_banner", "-loglevel", "info", "-i", self.main.video_input, ]

        args.extend(["-map", "0", "-c", "copy"])
        args.extend(["-map_metadata", "0", "-movflags", "use_metadata_tags"])

        for stream in video["streams"]:
            if stream['codec_type'] in ('audio', 'subtitle') and stream['tags']['language'] == 'und':
                args.extend(["-metadata:s:" + str(stream['index']), "language=" + self.tag])

        return self.runFfmpegOutput(args)

class ConvertCommand(MainSubCommand):
    default_audio: str | None = None
    default_subtitle: str | None = None

    @override
    def setup(self, args) -> int | None:
        parser = argparse.ArgumentParser(prog=args[0], description="Sets default streams")
        parser.add_argument("--default-audio", type=str, dest="default_audio", metavar="default audio track language, empty for none")
        parser.add_argument("--default-subtitle", type=str, dest="default_subtitle", metavar="default subtitle track language, empty for none")

        parser.parse_args(args[1:], namespace=self)

        if self.main.video_input is None or self.main.video_output is None or self.main.video_input == self.main.video_output:
            print("--vi video_input and --vo video_output must be both specified and must differ", file=sys.stderr)
            return 122

        return None

    @override
    def execute(self) -> int:
        video = self.main.readVideoData()

        args = ["ffmpeg", "-hide_banner", "-loglevel", "info", "-i", self.main.video_input, "-map", "0" ]

        if self.default_subtitle is not None:
            args.extend(["-default_mode", "infer_no_subs"])

        meta = []
        stream_counter = 0
        audio_counter = 0
        subtitle_counter = 0

        for stream in video["streams"]:
            if stream['codec_type'] == 'subtitle':
                language = stream['tags']['language']
                if self.default_subtitle is not None:
                    if language == self.default_subtitle:
                        meta.extend([f"-disposition:s:{subtitle_counter}", 'default'])
                    else:
                        meta.extend([f"-disposition:s:{subtitle_counter}", '0'])
                subtitle_counter = subtitle_counter + 1
            elif stream['codec_type'] == 'audio':
                language = stream['tags']['language']
                if self.default_audio is not None:
                    if language == self.default_audio:
                        meta.extend([f"-disposition:a:{audio_counter}", 'default'])
                    else:
                        meta.extend([f"-disposition:a:{audio_counter}", '0'])
                audio_counter = audio_counter + 1
            stream_counter = stream_counter + 1

        args.extend(["-c", "copy"])
        if Path(self.main.video_output).suffix != Path(self.main.video_input).suffix and Path(self.main.video_output).suffix == ".mp4":
            args.extend(["-c:s", "mov_text"])
        args.extend(["-map_metadata", "0", "-movflags", "use_metadata_tags"])
        args.extend(meta)
        args.append('--')
        args.append(self.main.video_output)

        safe = True
        try:
            print(f"Executing ffmpeg: {format_shell(args)}", file=sys.stderr)
            exit: int = subprocess.run(args).returncode
            if exit != 0:
                print(f"process exited with error: exit={exit} : args={format_shell(args)}", file=sys.stderr)
            #safe = False
            #shutil.copyfile(tmp, self.main.video_input)
            #safe = True
        finally:
            if safe:
                #silent_unlink(tmp)
                pass

        return exit


class ConcatCommand(MainSubCommand):
    inputs: list[str] = list()

    @override
    def setup(self, args) -> int | None:
        parser = argparse.ArgumentParser(prog=args[0], description="Concatenates files")
        parser.add_argument("inputs", type=str, action='extend', nargs='+')

        parser.parse_args(args[1:], namespace=self)

        if self.main.video_output is None or self.main.video_output in self.inputs:
            print("--vo video_output must be both specified and must differ from inputs", file=sys.stderr)
            return 122
        if self.main.video_input is not None:
            print("--vi video_input must not be specified, pass as regular arguments", file=sys.stderr)
            return 122

        return None

    @override
    def execute(self) -> int:
        listfile = tempfile.NamedTemporaryFile("w", delete_on_close=False)
        try:
            for input in self.inputs:
                print("file " + os.path.abspath(input), file = listfile)
            listfile.close()
            #subprocess.run(["cat", listfile.name]).returncode

            args = ["ffmpeg", "-f", "concat", "-safe", "0", "-i", listfile.name, "-c", "copy", self.main.video_output ]

            print(f"Executing ffmpeg: {format_shell(args)}", file=sys.stderr)
            exit: int = subprocess.run(args).returncode
            if exit != 0:
                print(f"process exited with error: exit={exit} : args={format_shell(args)}", file=sys.stderr)
            return exit
        finally:
            listfile.close()
            os.unlink(listfile.name)


class FromPicturesCommand(MainSubCommand):
    inputs: list[str] = list()

    # ffmpeg -loop 1 -t 7 -i P_20240907_055750.jpg -loop 1 -t 5 -i P_20240907_055802.jpg -loop 1 -t 7 -i P_20240907_111803.jpg  -filter_complex "[0:v]fade=t=out:st=4:d=1,scale=1920:1080:force_original_aspect_ratio=decrease,pad=1920:1080:(ow-iw)/2:(oh-ih)/2,setsar=1,drawtext=text='Text one, with colons \: escaped':x=(w-text_w)/2:y=(h/50):fontsize=40:fontcolor=#2ffa29:shadowx=3:shadowy=3[v0]; \
    #  [1:v]fade=t=in:st=0:d=1,fade=t=out:st=4:d=1,scale=1920:1080:force_original_aspect_ratio=decrease,pad=1920:1080:(ow-iw)/2:(oh-ih)/2,setsar=1,drawtext=text='Text 2':x=(w-text_w)/2:y=(h/50):fontsize=40:fontcolor=#2ffa29:shadowx=3:shadowy=3[v1]; \
    #  [2:v]fade=t=in:st=0:d=1,fade=t=out:st=4:d=1,scale=1920:1080:force_original_aspect_ratio=decrease,pad=1920:1080:(ow-iw)/2:(oh-ih)/2,setsar=1,drawtext=text='Text 3':x=(w-text_w)/2:y=(h/50):fontsize=40:fontcolor=#2ffa29:shadowx=3:shadowy=3[v2]; \
    #  [v0][v1][v2]concat=n=3:v=1:a=0,format=yuv420p[v];
    #  " -map "[v]" photos.mp4

    @override
    def setup(self, args) -> int | None:
        parser = argparse.ArgumentParser(prog=args[0], description="Concatenates files")
        parser.add_argument("inputs", type=str, action='extend', nargs='+')

        parser.parse_args(args[1:], namespace=self)

        if self.main.video_output is None or self.main.video_output in self.inputs:
            print("--vo video_output must be both specified and must differ from inputs", file=sys.stderr)
            return 122
        if self.main.video_input is not None:
            print("--vi video_input must not be specified, pass pictures as regular arguments", file=sys.stderr)
            return 122

        return None

    @override
    def execute(self) -> int:
        # TODO
        raise NotImplementedError("TODO: see example in the code to finish")


class AddTextCommand(MainSubCommand):
    class Input(BaseModel):
        text: str | None = None
        start_us: float | None = None
        duration_us: float | None = None

    class Cut(BaseModel):
        start_us: int = None
        end_us: int = None
        inputs: list[AddTextCommand.Input] = list()

    videoManipulations: VideoManipulations = VideoManipulations()

    size: str = "40"
    color: str = "#2ffa29"
    shadow_offset: int = 2
    duration_us: float = 15000000
    fade_in_us: float = 1000000
    fade_out_us: float = 1000000
    x_pos: str = "(w-text_w)/2"
    y_pos: str = "(h/50)"
    inputs_str: list[str] = list()

    inputs: list[Input] = list()

    video: VideoData
    length_us: int

    # ffmpeg -loop 1 -t 7 -i P_20240907_055750.jpg -loop 1 -t 5 -i P_20240907_055802.jpg -loop 1 -t 7 -i P_20240907_111803.jpg  -filter_complex "[0:v]fade=t=out:st=4:d=1,scale=1920:1080:force_original_aspect_ratio=decrease,pad=1920:1080:(ow-iw)/2:(oh-ih)/2,setsar=1,drawtext=text='Text one, with colons \: escaped':x=(w-text_w)/2:y=(h/50):fontsize=40:fontcolor=#2ffa29:shadowx=3:shadowy=3[v0]; \
    #  [1:v]fade=t=in:st=0:d=1,fade=t=out:st=4:d=1,scale=1920:1080:force_original_aspect_ratio=decrease,pad=1920:1080:(ow-iw)/2:(oh-ih)/2,setsar=1,drawtext=text='Text 2':x=(w-text_w)/2:y=(h/50):fontsize=40:fontcolor=#2ffa29:shadowx=3:shadowy=3[v1]; \
    #  [2:v]fade=t=in:st=0:d=1,fade=t=out:st=4:d=1,scale=1920:1080:force_original_aspect_ratio=decrease,pad=1920:1080:(ow-iw)/2:(oh-ih)/2,setsar=1,drawtext=text='Text 3':x=(w-text_w)/2:y=(h/50):fontsize=40:fontcolor=#2ffa29:shadowx=3:shadowy=3[v2]; \
    #  [v0][v1][v2]concat=n=3:v=1:a=0,format=yuv420p[v];
    #  " -map "[v]" photos.mp4
    # :enable='between(t,23,31)

    @override
    def setup(self, args) -> int | None:
        parser = argparse.ArgumentParser(prog=args[0], description="Add text")
        parser.add_argument("--size", type=str, dest="size")
        parser.add_argument("--color", type=str, dest="color")
        parser.add_argument("--shadow-offset", type=int, dest="shadow_offset")
        parser.add_argument("--duration", type=TimeFormat.str_to_us_time, dest="duration_us")
        parser.add_argument("--fade-in", type=TimeFormat.str_to_us_time, dest="fade_in_us",)
        parser.add_argument("--fade-out", type=TimeFormat.str_to_us_time, dest="fade_out_us")
        parser.add_argument("--x", type=str, dest="x_pos")
        parser.add_argument("--y", type=str, dest="y_pos")
        parser.add_argument("inputs_str", type=str, action='extend', nargs='+')

        parser.parse_args(args[1:], namespace=self)

        if self.main.video_output is None:
            print("--vo video_output must be both specified and must differ from inputs", file=sys.stderr)
            return 122
        if self.main.video_input is None or self.main.video_input == self.main.video_output:
            print("--vi video_input must be specified and must be different from video output", file=sys.stderr)
            return 122

        for input_str in self.inputs_str:
            pending: str = input_str
            input: AddTextCommand.Input = AddTextCommand.Input()
            while True:
                equal = pending.find('=')
                if equal < 0:
                    raise ValueError("Cannot find = in input specification while text not yet specified: " + pending)
                key = pending[:equal]
                if key == "text":
                    input.text = pending[equal + 1:]
                    break
                colon = pending.index(':', equal)
                if colon < 0:
                    raise ValueError("Cannot find : in input specification: " + pending)
                value = pending[equal + 1 : colon]
                if key == "start":
                    input.start_us = TimeFormat.str_to_us_time(value)
                elif key == "duration":
                    input.duration_us = int(float(value) * 1000000)
                else:
                    try:
                        setattr(input, key, value)
                    except BaseException as ex:
                        raise KeyError("Invalid attribute for text, only start, duration and text are supported: " + key) from ex
                pending = pending[colon + 1:]
            if input.start_us is None:
                raise KeyError("start attribute is mandatory: " + input_str)
            if input.duration_us is None:
                input.duration_us = self.duration_us
            self.inputs.append(input)

        return None

    @override
    def execute(self) -> int:
        self.video = VideoData(self.main.video_input)
        self.length_us = self.video.duration()
        print("Do the work: " + str(self.inputs))
        with tempfile.TemporaryDirectory(suffix="-zbynek-video-util", delete=False) as tmp:
            cuts = list[AddTextCommand.Cut]()

            for input in self.inputs:
                self.getCut(cuts, input.start_us, input.start_us + input.duration_us).inputs.append(input)
            cuts.sort(key=lambda o: o.start_us)

            parts = list[str]()
            time_us: int = 0
            for cut in cuts:
                if time_us < cut.start_us:
                    parts.append(self.cutVideo(tmp, len(parts), time_us, cut.start_us))
                    time_us = cut.start_us
                parts.append(self.cutVideoWithTexts(tmp, len(parts), time_us, cut.end_us, cut.inputs))
                time_us = cut.end_us

            if time_us < self.video.duration():
                parts.append(self.cutVideo(tmp, len(cuts), time_us, self.video.duration()))

            self.videoManipulations.concatVideos(self.main.video_output, parts)

        return 0

    def getCut(self, cuts: list[AddTextCommand.Cut], start_time_us: int, end_time_us: int) -> Cut:
        if end_time_us > self.video.duration():
            raise ValueError("end time beyond video length: " + TimeFormat.us_time_to_str(end_time_us))
        affected = list()
        newCut = AddTextCommand.Cut(
            start_us=self.calculateFloorBoundary(start_time_us),
            end_us=self.calculateCeilBoundary(end_time_us)
        )
        print("new: " + str(newCut))
        print("old: " + str(cuts))
        for cut in [newCut] + cuts:
            if cut.end_us >= start_time_us and cut.start_us <= end_time_us:
                affected.append(cut)
        print("aff: " + str(affected))
        if len(affected) == 1:
            cuts.append(newCut)
            return newCut
        else:
            for cut in affected:
                cuts.remove(cut)
            cut = AddTextCommand.Cut(
                start_us=reduce(min, map(lambda c: c.start_us, affected)),
                end_us=reduce(max, map(lambda c: c.end_us, affected)),
                inputs=reduce(lambda x, y: x + y, map(lambda c: c.inputs, affected))
            )
            cuts.append(cut)
            return cut

    def calculateFloorBoundary(self, time_us: int):
        return int(floor(time_us / 600000000)) * 600000000

    def calculateCeilBoundary(self, time_us: int):
        return min(int(ceil(time_us / 600000000.0)) * 600000000, self.length_us)

    def cutVideo(self, tmp: str, index: int, start_us: int, end_us: int) -> str:
        print(f"cutting: {start_us} {end_us}")
        output = tmp + "/" + ("%04d.mp4" % (index))
        self.videoManipulations.cutVideo(output, self.main.video_input, start_us, end_us)
        return output

    def cutVideoWithTexts(self, tmp: str, index: int, start_us: int, end_us: int, inputs: list[AddTextCommand.Input]) -> str:
        output = tmp + "/" + ("%04d.mp4" % (index))
        self.videoManipulations.cutVideo(output, self.main.video_input, start_us, end_us)
        return output


class Main(Command):
    command: Command | None = None
    video_input: str | None = None
    video_output: str | None = None
    subcommand: list[str] = []

    @override
    def setup(self, args) -> int | None:
        parser = argparse.ArgumentParser(prog=args[0], description="Subtitles operations")
        parser.add_argument("--vi", "--video-input", type=str, dest="video_input")
        parser.add_argument("--vo", "--video-output", type=str, dest="video_output")
        parser.add_argument("subcommand", type=str, nargs=argparse.REMAINDER)

        parser.parse_args(args[1:], namespace=self)

        if len(self.subcommand) < 1:
            print(f"usage: {args[0]} subcommand ...", file=sys.stderr)
            return 122

        if self.subcommand[0] == 'subtitle-embed':
            self.command = SubtitleEmbedCommand(self)
        elif self.subcommand[0] == 'subtitle-convert':
            self.command = SubtitleConvertCommand(self)
        elif self.subcommand[0] == 'convert':
            self.command = ConvertCommand(self)
        elif self.subcommand[0] == 'concat':
            self.command = ConcatCommand(self)
        elif self.subcommand[0] == 'language-reorder':
            self.command = LanguageReorderCommand(self)
        elif self.subcommand[0] == 'retag-und':
            self.command = RetagUndCommand(self)
        elif self.subcommand[0] == 'add-text':
            self.command = AddTextCommand(self)
        else:
            print("Supported subcommands: convert concat subtitle-embed subtitle-convert language-reorder add-text retag-und", file=sys.stderr)
            return 122

        self.subcommand[0] = args[0] + " " + self.subcommand[0]
        return self.command.run(self.subcommand)

    def readVideoData(self) -> dict[str, object]:
        cmd = ["ffprobe", "-hide_banner", "-loglevel", "fatal", "-show_error", "-show_format", "-show_streams", "-show_programs", "-show_chapters", "-show_private_data", "-print_format", "json", "--", self.video_input]
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, text=True)
        data = json.load(proc.stdout)
        ret = proc.wait()
        if ret != 0:
            raise ValueError("Command failed: ret=" + str(ret) + " : " + format_shell(cmd) + "\n" + json.dumps(data))
        return data


if __name__ == "__main__":
    logging.basicConfig(
        format='%(asctime)s %(levelname)-8s %(message)s',
        level=logging.INFO,
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    sys.exit(Main().run(sys.argv))
